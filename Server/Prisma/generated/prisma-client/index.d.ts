// Code generated by Prisma (prisma@1.34.7). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  cardTemplate: (where?: CardTemplateWhereInput) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  eventPackage: (where?: EventPackageWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  leaveDay: (where?: LeaveDayWhereInput) => Promise<boolean>;
  photoFrameTemplate: (
    where?: PhotoFrameTemplateWhereInput
  ) => Promise<boolean>;
  position: (where?: PositionWhereInput) => Promise<boolean>;
  staff: (where?: StaffWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cardTemplate: (
    where: CardTemplateWhereUniqueInput
  ) => CardTemplateNullablePromise;
  cardTemplates: (args?: {
    where?: CardTemplateWhereInput;
    orderBy?: CardTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CardTemplate>;
  cardTemplatesConnection: (args?: {
    where?: CardTemplateWhereInput;
    orderBy?: CardTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CardTemplateConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentNullablePromise;
  departments: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Department>;
  departmentsConnection: (args?: {
    where?: DepartmentWhereInput;
    orderBy?: DepartmentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DepartmentConnectionPromise;
  eventPackage: (
    where: EventPackageWhereUniqueInput
  ) => EventPackageNullablePromise;
  eventPackages: (args?: {
    where?: EventPackageWhereInput;
    orderBy?: EventPackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<EventPackage>;
  eventPackagesConnection: (args?: {
    where?: EventPackageWhereInput;
    orderBy?: EventPackageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventPackageConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  leaveDay: (where: LeaveDayWhereUniqueInput) => LeaveDayNullablePromise;
  leaveDays: (args?: {
    where?: LeaveDayWhereInput;
    orderBy?: LeaveDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LeaveDay>;
  leaveDaysConnection: (args?: {
    where?: LeaveDayWhereInput;
    orderBy?: LeaveDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeaveDayConnectionPromise;
  photoFrameTemplate: (
    where: PhotoFrameTemplateWhereUniqueInput
  ) => PhotoFrameTemplateNullablePromise;
  photoFrameTemplates: (args?: {
    where?: PhotoFrameTemplateWhereInput;
    orderBy?: PhotoFrameTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhotoFrameTemplate>;
  photoFrameTemplatesConnection: (args?: {
    where?: PhotoFrameTemplateWhereInput;
    orderBy?: PhotoFrameTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhotoFrameTemplateConnectionPromise;
  position: (where: PositionWhereUniqueInput) => PositionNullablePromise;
  positions: (args?: {
    where?: PositionWhereInput;
    orderBy?: PositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Position>;
  positionsConnection: (args?: {
    where?: PositionWhereInput;
    orderBy?: PositionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PositionConnectionPromise;
  staff: (where: StaffWhereUniqueInput) => StaffNullablePromise;
  staffs: (args?: {
    where?: StaffWhereInput;
    orderBy?: StaffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Staff>;
  staffsConnection: (args?: {
    where?: StaffWhereInput;
    orderBy?: StaffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StaffConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCardTemplate: (data: CardTemplateCreateInput) => CardTemplatePromise;
  updateCardTemplate: (args: {
    data: CardTemplateUpdateInput;
    where: CardTemplateWhereUniqueInput;
  }) => CardTemplatePromise;
  updateManyCardTemplates: (args: {
    data: CardTemplateUpdateManyMutationInput;
    where?: CardTemplateWhereInput;
  }) => BatchPayloadPromise;
  upsertCardTemplate: (args: {
    where: CardTemplateWhereUniqueInput;
    create: CardTemplateCreateInput;
    update: CardTemplateUpdateInput;
  }) => CardTemplatePromise;
  deleteCardTemplate: (
    where: CardTemplateWhereUniqueInput
  ) => CardTemplatePromise;
  deleteManyCardTemplates: (
    where?: CardTemplateWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (args: {
    data: DepartmentUpdateInput;
    where: DepartmentWhereUniqueInput;
  }) => DepartmentPromise;
  updateManyDepartments: (args: {
    data: DepartmentUpdateManyMutationInput;
    where?: DepartmentWhereInput;
  }) => BatchPayloadPromise;
  upsertDepartment: (args: {
    where: DepartmentWhereUniqueInput;
    create: DepartmentCreateInput;
    update: DepartmentUpdateInput;
  }) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createEventPackage: (data: EventPackageCreateInput) => EventPackagePromise;
  updateEventPackage: (args: {
    data: EventPackageUpdateInput;
    where: EventPackageWhereUniqueInput;
  }) => EventPackagePromise;
  updateManyEventPackages: (args: {
    data: EventPackageUpdateManyMutationInput;
    where?: EventPackageWhereInput;
  }) => BatchPayloadPromise;
  upsertEventPackage: (args: {
    where: EventPackageWhereUniqueInput;
    create: EventPackageCreateInput;
    update: EventPackageUpdateInput;
  }) => EventPackagePromise;
  deleteEventPackage: (
    where: EventPackageWhereUniqueInput
  ) => EventPackagePromise;
  deleteManyEventPackages: (
    where?: EventPackageWhereInput
  ) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createLeaveDay: (data: LeaveDayCreateInput) => LeaveDayPromise;
  updateLeaveDay: (args: {
    data: LeaveDayUpdateInput;
    where: LeaveDayWhereUniqueInput;
  }) => LeaveDayPromise;
  updateManyLeaveDays: (args: {
    data: LeaveDayUpdateManyMutationInput;
    where?: LeaveDayWhereInput;
  }) => BatchPayloadPromise;
  upsertLeaveDay: (args: {
    where: LeaveDayWhereUniqueInput;
    create: LeaveDayCreateInput;
    update: LeaveDayUpdateInput;
  }) => LeaveDayPromise;
  deleteLeaveDay: (where: LeaveDayWhereUniqueInput) => LeaveDayPromise;
  deleteManyLeaveDays: (where?: LeaveDayWhereInput) => BatchPayloadPromise;
  createPhotoFrameTemplate: (
    data: PhotoFrameTemplateCreateInput
  ) => PhotoFrameTemplatePromise;
  updatePhotoFrameTemplate: (args: {
    data: PhotoFrameTemplateUpdateInput;
    where: PhotoFrameTemplateWhereUniqueInput;
  }) => PhotoFrameTemplatePromise;
  updateManyPhotoFrameTemplates: (args: {
    data: PhotoFrameTemplateUpdateManyMutationInput;
    where?: PhotoFrameTemplateWhereInput;
  }) => BatchPayloadPromise;
  upsertPhotoFrameTemplate: (args: {
    where: PhotoFrameTemplateWhereUniqueInput;
    create: PhotoFrameTemplateCreateInput;
    update: PhotoFrameTemplateUpdateInput;
  }) => PhotoFrameTemplatePromise;
  deletePhotoFrameTemplate: (
    where: PhotoFrameTemplateWhereUniqueInput
  ) => PhotoFrameTemplatePromise;
  deleteManyPhotoFrameTemplates: (
    where?: PhotoFrameTemplateWhereInput
  ) => BatchPayloadPromise;
  createPosition: (data: PositionCreateInput) => PositionPromise;
  updatePosition: (args: {
    data: PositionUpdateInput;
    where: PositionWhereUniqueInput;
  }) => PositionPromise;
  updateManyPositions: (args: {
    data: PositionUpdateManyMutationInput;
    where?: PositionWhereInput;
  }) => BatchPayloadPromise;
  upsertPosition: (args: {
    where: PositionWhereUniqueInput;
    create: PositionCreateInput;
    update: PositionUpdateInput;
  }) => PositionPromise;
  deletePosition: (where: PositionWhereUniqueInput) => PositionPromise;
  deleteManyPositions: (where?: PositionWhereInput) => BatchPayloadPromise;
  createStaff: (data: StaffCreateInput) => StaffPromise;
  updateStaff: (args: {
    data: StaffUpdateInput;
    where: StaffWhereUniqueInput;
  }) => StaffPromise;
  updateManyStaffs: (args: {
    data: StaffUpdateManyMutationInput;
    where?: StaffWhereInput;
  }) => BatchPayloadPromise;
  upsertStaff: (args: {
    where: StaffWhereUniqueInput;
    create: StaffCreateInput;
    update: StaffUpdateInput;
  }) => StaffPromise;
  deleteStaff: (where: StaffWhereUniqueInput) => StaffPromise;
  deleteManyStaffs: (where?: StaffWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cardTemplate: (
    where?: CardTemplateSubscriptionWhereInput
  ) => CardTemplateSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  eventPackage: (
    where?: EventPackageSubscriptionWhereInput
  ) => EventPackageSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  leaveDay: (
    where?: LeaveDaySubscriptionWhereInput
  ) => LeaveDaySubscriptionPayloadSubscription;
  photoFrameTemplate: (
    where?: PhotoFrameTemplateSubscriptionWhereInput
  ) => PhotoFrameTemplateSubscriptionPayloadSubscription;
  position: (
    where?: PositionSubscriptionWhereInput
  ) => PositionSubscriptionPayloadSubscription;
  staff: (
    where?: StaffSubscriptionWhereInput
  ) => StaffSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LeaveDayOrderByInput =
  | "LeaveID_ASC"
  | "LeaveID_DESC"
  | "Day_ASC"
  | "Day_DESC"
  | "Month_ASC"
  | "Month_DESC"
  | "Year_ASC"
  | "Year_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CustomerOrderByInput =
  | "CustomerID_ASC"
  | "CustomerID_DESC"
  | "CustomerName_ASC"
  | "CustomerName_DESC"
  | "Address_ASC"
  | "Address_DESC"
  | "Gender_ASC"
  | "Gender_DESC"
  | "Phone_ASC"
  | "Phone_DESC"
  | "CustomerEmail_ASC"
  | "CustomerEmail_DESC"
  | "Ethnicity_ASC"
  | "Ethnicity_DESC"
  | "LoyalityPoints_ASC"
  | "LoyalityPoints_DESC";

export type DepartmentOrderByInput =
  | "departmentID_ASC"
  | "departmentID_DESC"
  | "name_ASC"
  | "name_DESC";

export type EventPackageOrderByInput =
  | "PackageID_ASC"
  | "PackageID_DESC"
  | "PackageName_ASC"
  | "PackageName_DESC"
  | "BookingCost_ASC"
  | "BookingCost_DESC"
  | "FoodPackage_ASC"
  | "FoodPackage_DESC"
  | "PhotographyServices_ASC"
  | "PhotographyServices_DESC"
  | "Sounds_ASC"
  | "Sounds_DESC";

export type ItemOrderByInput =
  | "ItemId_ASC"
  | "ItemId_DESC"
  | "ItemName_ASC"
  | "ItemName_DESC"
  | "Category_ASC"
  | "Category_DESC"
  | "Price_ASC"
  | "Price_DESC"
  | "Stock_ASC"
  | "Stock_DESC"
  | "Brand_ASC"
  | "Brand_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "reset_ASC"
  | "reset_DESC";

export type PhotoFrameTemplateOrderByInput =
  | "FrameID_ASC"
  | "FrameID_DESC"
  | "FrameName_ASC"
  | "FrameName_DESC"
  | "FrameMaterial_ASC"
  | "FrameMaterial_DESC"
  | "PhotoFinish_ASC"
  | "PhotoFinish_DESC"
  | "Price_ASC"
  | "Price_DESC"
  | "Dimensions_ASC"
  | "Dimensions_DESC";

export type CardTemplateOrderByInput =
  | "CardId_ASC"
  | "CardId_DESC"
  | "CardName_ASC"
  | "CardName_DESC"
  | "Category_ASC"
  | "Category_DESC"
  | "Price_ASC"
  | "Price_DESC"
  | "Size_ASC"
  | "Size_DESC"
  | "Material_ASC"
  | "Material_DESC"
  | "SearchTags_ASC"
  | "SearchTags_DESC";

export type PositionOrderByInput =
  | "positionId_ASC"
  | "positionId_DESC"
  | "basicSalary_ASC"
  | "basicSalary_DESC"
  | "otRate_ASC"
  | "otRate_DESC"
  | "jobRole_ASC"
  | "jobRole_DESC"
  | "contractBasis_ASC"
  | "contractBasis_DESC"
  | "PerContractPrice_ASC"
  | "PerContractPrice_DESC";

export type StaffOrderByInput =
  | "employeeID_ASC"
  | "employeeID_DESC"
  | "employeeName_ASC"
  | "employeeName_DESC"
  | "nicNumber_ASC"
  | "nicNumber_DESC"
  | "bankAccountNumber_ASC"
  | "bankAccountNumber_DESC"
  | "address_ASC"
  | "address_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "workEmail_ASC"
  | "workEmail_DESC"
  | "password_ASC"
  | "password_DESC"
  | "Age_ASC"
  | "Age_DESC";

export interface DepartmentUpdateDataInput {
  name?: Maybe<String>;
}

export interface CustomerUpdateInput {
  CustomerName?: Maybe<String>;
  Address?: Maybe<String>;
  Gender?: Maybe<String>;
  Phone?: Maybe<Int>;
  CustomerEmail?: Maybe<String>;
  Ethnicity?: Maybe<String>;
  LoyalityPoints?: Maybe<Float>;
}

export interface PositionUpdateOneInput {
  create?: Maybe<PositionCreateInput>;
  update?: Maybe<PositionUpdateDataInput>;
  upsert?: Maybe<PositionUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PositionWhereUniqueInput>;
}

export type CardTemplateWhereUniqueInput = AtLeastOne<{
  CardId: Maybe<ID_Input>;
  CardName?: Maybe<String>;
}>;

export interface StaffUpdateDataInput {
  employeeName?: Maybe<String>;
  nicNumber?: Maybe<String>;
  bankAccountNumber?: Maybe<String>;
  position?: Maybe<PositionUpdateOneInput>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  workEmail?: Maybe<String>;
  password?: Maybe<String>;
  Age?: Maybe<Int>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  CustomerID: Maybe<ID_Input>;
  Phone?: Maybe<Int>;
  CustomerEmail?: Maybe<String>;
}>;

export interface StaffUpdateOneRequiredInput {
  create?: Maybe<StaffCreateInput>;
  update?: Maybe<StaffUpdateDataInput>;
  upsert?: Maybe<StaffUpsertNestedInput>;
  connect?: Maybe<StaffWhereUniqueInput>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export type PhotoFrameTemplateWhereUniqueInput = AtLeastOne<{
  FrameID: Maybe<ID_Input>;
  FrameName?: Maybe<String>;
}>;

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  reset?: Maybe<String>;
}

export interface LeaveDayUpdateInput {
  StaffMember?: Maybe<StaffUpdateOneRequiredInput>;
  Day?: Maybe<Int>;
  Month?: Maybe<Int>;
  Year?: Maybe<Int>;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  departmentID: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface PhotoFrameTemplateWhereInput {
  FrameID?: Maybe<ID_Input>;
  FrameID_not?: Maybe<ID_Input>;
  FrameID_in?: Maybe<ID_Input[] | ID_Input>;
  FrameID_not_in?: Maybe<ID_Input[] | ID_Input>;
  FrameID_lt?: Maybe<ID_Input>;
  FrameID_lte?: Maybe<ID_Input>;
  FrameID_gt?: Maybe<ID_Input>;
  FrameID_gte?: Maybe<ID_Input>;
  FrameID_contains?: Maybe<ID_Input>;
  FrameID_not_contains?: Maybe<ID_Input>;
  FrameID_starts_with?: Maybe<ID_Input>;
  FrameID_not_starts_with?: Maybe<ID_Input>;
  FrameID_ends_with?: Maybe<ID_Input>;
  FrameID_not_ends_with?: Maybe<ID_Input>;
  FrameName?: Maybe<String>;
  FrameName_not?: Maybe<String>;
  FrameName_in?: Maybe<String[] | String>;
  FrameName_not_in?: Maybe<String[] | String>;
  FrameName_lt?: Maybe<String>;
  FrameName_lte?: Maybe<String>;
  FrameName_gt?: Maybe<String>;
  FrameName_gte?: Maybe<String>;
  FrameName_contains?: Maybe<String>;
  FrameName_not_contains?: Maybe<String>;
  FrameName_starts_with?: Maybe<String>;
  FrameName_not_starts_with?: Maybe<String>;
  FrameName_ends_with?: Maybe<String>;
  FrameName_not_ends_with?: Maybe<String>;
  FrameMaterial?: Maybe<String>;
  FrameMaterial_not?: Maybe<String>;
  FrameMaterial_in?: Maybe<String[] | String>;
  FrameMaterial_not_in?: Maybe<String[] | String>;
  FrameMaterial_lt?: Maybe<String>;
  FrameMaterial_lte?: Maybe<String>;
  FrameMaterial_gt?: Maybe<String>;
  FrameMaterial_gte?: Maybe<String>;
  FrameMaterial_contains?: Maybe<String>;
  FrameMaterial_not_contains?: Maybe<String>;
  FrameMaterial_starts_with?: Maybe<String>;
  FrameMaterial_not_starts_with?: Maybe<String>;
  FrameMaterial_ends_with?: Maybe<String>;
  FrameMaterial_not_ends_with?: Maybe<String>;
  PhotoFinish?: Maybe<String>;
  PhotoFinish_not?: Maybe<String>;
  PhotoFinish_in?: Maybe<String[] | String>;
  PhotoFinish_not_in?: Maybe<String[] | String>;
  PhotoFinish_lt?: Maybe<String>;
  PhotoFinish_lte?: Maybe<String>;
  PhotoFinish_gt?: Maybe<String>;
  PhotoFinish_gte?: Maybe<String>;
  PhotoFinish_contains?: Maybe<String>;
  PhotoFinish_not_contains?: Maybe<String>;
  PhotoFinish_starts_with?: Maybe<String>;
  PhotoFinish_not_starts_with?: Maybe<String>;
  PhotoFinish_ends_with?: Maybe<String>;
  PhotoFinish_not_ends_with?: Maybe<String>;
  Price?: Maybe<Int>;
  Price_not?: Maybe<Int>;
  Price_in?: Maybe<Int[] | Int>;
  Price_not_in?: Maybe<Int[] | Int>;
  Price_lt?: Maybe<Int>;
  Price_lte?: Maybe<Int>;
  Price_gt?: Maybe<Int>;
  Price_gte?: Maybe<Int>;
  Dimensions?: Maybe<String>;
  Dimensions_not?: Maybe<String>;
  Dimensions_in?: Maybe<String[] | String>;
  Dimensions_not_in?: Maybe<String[] | String>;
  Dimensions_lt?: Maybe<String>;
  Dimensions_lte?: Maybe<String>;
  Dimensions_gt?: Maybe<String>;
  Dimensions_gte?: Maybe<String>;
  Dimensions_contains?: Maybe<String>;
  Dimensions_not_contains?: Maybe<String>;
  Dimensions_starts_with?: Maybe<String>;
  Dimensions_not_starts_with?: Maybe<String>;
  Dimensions_ends_with?: Maybe<String>;
  Dimensions_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhotoFrameTemplateWhereInput[] | PhotoFrameTemplateWhereInput>;
  OR?: Maybe<PhotoFrameTemplateWhereInput[] | PhotoFrameTemplateWhereInput>;
  NOT?: Maybe<PhotoFrameTemplateWhereInput[] | PhotoFrameTemplateWhereInput>;
}

export interface DepartmentWhereInput {
  departmentID?: Maybe<ID_Input>;
  departmentID_not?: Maybe<ID_Input>;
  departmentID_in?: Maybe<ID_Input[] | ID_Input>;
  departmentID_not_in?: Maybe<ID_Input[] | ID_Input>;
  departmentID_lt?: Maybe<ID_Input>;
  departmentID_lte?: Maybe<ID_Input>;
  departmentID_gt?: Maybe<ID_Input>;
  departmentID_gte?: Maybe<ID_Input>;
  departmentID_contains?: Maybe<ID_Input>;
  departmentID_not_contains?: Maybe<ID_Input>;
  departmentID_starts_with?: Maybe<ID_Input>;
  departmentID_not_starts_with?: Maybe<ID_Input>;
  departmentID_ends_with?: Maybe<ID_Input>;
  departmentID_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  OR?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
  NOT?: Maybe<DepartmentWhereInput[] | DepartmentWhereInput>;
}

export interface PhotoFrameTemplateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhotoFrameTemplateWhereInput>;
  AND?: Maybe<
    | PhotoFrameTemplateSubscriptionWhereInput[]
    | PhotoFrameTemplateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhotoFrameTemplateSubscriptionWhereInput[]
    | PhotoFrameTemplateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhotoFrameTemplateSubscriptionWhereInput[]
    | PhotoFrameTemplateSubscriptionWhereInput
  >;
}

export interface StaffUpdateManyMutationInput {
  employeeName?: Maybe<String>;
  nicNumber?: Maybe<String>;
  bankAccountNumber?: Maybe<String>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  workEmail?: Maybe<String>;
  password?: Maybe<String>;
  Age?: Maybe<Int>;
}

export interface DepartmentCreateOneInput {
  create?: Maybe<DepartmentCreateInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface PositionUpdateManyMutationInput {
  basicSalary?: Maybe<Float>;
  otRate?: Maybe<Float>;
  jobRole?: Maybe<String>;
  contractBasis?: Maybe<Boolean>;
  PerContractPrice?: Maybe<Float>;
}

export interface PositionCreateInput {
  positionId?: Maybe<ID_Input>;
  department: DepartmentCreateOneInput;
  basicSalary?: Maybe<Float>;
  otRate?: Maybe<Float>;
  jobRole?: Maybe<String>;
  contractBasis?: Maybe<Boolean>;
  PerContractPrice?: Maybe<Float>;
}

export interface PositionUpdateInput {
  department?: Maybe<DepartmentUpdateOneRequiredInput>;
  basicSalary?: Maybe<Float>;
  otRate?: Maybe<Float>;
  jobRole?: Maybe<String>;
  contractBasis?: Maybe<Boolean>;
  PerContractPrice?: Maybe<Float>;
}

export interface PositionCreateOneInput {
  create?: Maybe<PositionCreateInput>;
  connect?: Maybe<PositionWhereUniqueInput>;
}

export interface EventPackageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventPackageWhereInput>;
  AND?: Maybe<
    EventPackageSubscriptionWhereInput[] | EventPackageSubscriptionWhereInput
  >;
  OR?: Maybe<
    EventPackageSubscriptionWhereInput[] | EventPackageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EventPackageSubscriptionWhereInput[] | EventPackageSubscriptionWhereInput
  >;
}

export type PositionWhereUniqueInput = AtLeastOne<{
  positionId: Maybe<ID_Input>;
  jobRole?: Maybe<String>;
}>;

export interface PhotoFrameTemplateUpdateInput {
  FrameName?: Maybe<String>;
  FrameMaterial?: Maybe<String>;
  PhotoFinish?: Maybe<String>;
  Price?: Maybe<Int>;
  Dimensions?: Maybe<String>;
}

export interface CardTemplateWhereInput {
  CardId?: Maybe<ID_Input>;
  CardId_not?: Maybe<ID_Input>;
  CardId_in?: Maybe<ID_Input[] | ID_Input>;
  CardId_not_in?: Maybe<ID_Input[] | ID_Input>;
  CardId_lt?: Maybe<ID_Input>;
  CardId_lte?: Maybe<ID_Input>;
  CardId_gt?: Maybe<ID_Input>;
  CardId_gte?: Maybe<ID_Input>;
  CardId_contains?: Maybe<ID_Input>;
  CardId_not_contains?: Maybe<ID_Input>;
  CardId_starts_with?: Maybe<ID_Input>;
  CardId_not_starts_with?: Maybe<ID_Input>;
  CardId_ends_with?: Maybe<ID_Input>;
  CardId_not_ends_with?: Maybe<ID_Input>;
  CardName?: Maybe<String>;
  CardName_not?: Maybe<String>;
  CardName_in?: Maybe<String[] | String>;
  CardName_not_in?: Maybe<String[] | String>;
  CardName_lt?: Maybe<String>;
  CardName_lte?: Maybe<String>;
  CardName_gt?: Maybe<String>;
  CardName_gte?: Maybe<String>;
  CardName_contains?: Maybe<String>;
  CardName_not_contains?: Maybe<String>;
  CardName_starts_with?: Maybe<String>;
  CardName_not_starts_with?: Maybe<String>;
  CardName_ends_with?: Maybe<String>;
  CardName_not_ends_with?: Maybe<String>;
  Category?: Maybe<String>;
  Category_not?: Maybe<String>;
  Category_in?: Maybe<String[] | String>;
  Category_not_in?: Maybe<String[] | String>;
  Category_lt?: Maybe<String>;
  Category_lte?: Maybe<String>;
  Category_gt?: Maybe<String>;
  Category_gte?: Maybe<String>;
  Category_contains?: Maybe<String>;
  Category_not_contains?: Maybe<String>;
  Category_starts_with?: Maybe<String>;
  Category_not_starts_with?: Maybe<String>;
  Category_ends_with?: Maybe<String>;
  Category_not_ends_with?: Maybe<String>;
  Price?: Maybe<Float>;
  Price_not?: Maybe<Float>;
  Price_in?: Maybe<Float[] | Float>;
  Price_not_in?: Maybe<Float[] | Float>;
  Price_lt?: Maybe<Float>;
  Price_lte?: Maybe<Float>;
  Price_gt?: Maybe<Float>;
  Price_gte?: Maybe<Float>;
  Size?: Maybe<String>;
  Size_not?: Maybe<String>;
  Size_in?: Maybe<String[] | String>;
  Size_not_in?: Maybe<String[] | String>;
  Size_lt?: Maybe<String>;
  Size_lte?: Maybe<String>;
  Size_gt?: Maybe<String>;
  Size_gte?: Maybe<String>;
  Size_contains?: Maybe<String>;
  Size_not_contains?: Maybe<String>;
  Size_starts_with?: Maybe<String>;
  Size_not_starts_with?: Maybe<String>;
  Size_ends_with?: Maybe<String>;
  Size_not_ends_with?: Maybe<String>;
  Material?: Maybe<String>;
  Material_not?: Maybe<String>;
  Material_in?: Maybe<String[] | String>;
  Material_not_in?: Maybe<String[] | String>;
  Material_lt?: Maybe<String>;
  Material_lte?: Maybe<String>;
  Material_gt?: Maybe<String>;
  Material_gte?: Maybe<String>;
  Material_contains?: Maybe<String>;
  Material_not_contains?: Maybe<String>;
  Material_starts_with?: Maybe<String>;
  Material_not_starts_with?: Maybe<String>;
  Material_ends_with?: Maybe<String>;
  Material_not_ends_with?: Maybe<String>;
  SearchTags?: Maybe<String>;
  SearchTags_not?: Maybe<String>;
  SearchTags_in?: Maybe<String[] | String>;
  SearchTags_not_in?: Maybe<String[] | String>;
  SearchTags_lt?: Maybe<String>;
  SearchTags_lte?: Maybe<String>;
  SearchTags_gt?: Maybe<String>;
  SearchTags_gte?: Maybe<String>;
  SearchTags_contains?: Maybe<String>;
  SearchTags_not_contains?: Maybe<String>;
  SearchTags_starts_with?: Maybe<String>;
  SearchTags_not_starts_with?: Maybe<String>;
  SearchTags_ends_with?: Maybe<String>;
  SearchTags_not_ends_with?: Maybe<String>;
  AND?: Maybe<CardTemplateWhereInput[] | CardTemplateWhereInput>;
  OR?: Maybe<CardTemplateWhereInput[] | CardTemplateWhereInput>;
  NOT?: Maybe<CardTemplateWhereInput[] | CardTemplateWhereInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  ItemId: Maybe<ID_Input>;
  ItemName?: Maybe<String>;
}>;

export interface StaffCreateInput {
  employeeID?: Maybe<ID_Input>;
  employeeName?: Maybe<String>;
  nicNumber?: Maybe<String>;
  bankAccountNumber?: Maybe<String>;
  position?: Maybe<PositionCreateOneInput>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  workEmail?: Maybe<String>;
  password?: Maybe<String>;
  Age?: Maybe<Int>;
}

export interface ItemWhereInput {
  ItemId?: Maybe<ID_Input>;
  ItemId_not?: Maybe<ID_Input>;
  ItemId_in?: Maybe<ID_Input[] | ID_Input>;
  ItemId_not_in?: Maybe<ID_Input[] | ID_Input>;
  ItemId_lt?: Maybe<ID_Input>;
  ItemId_lte?: Maybe<ID_Input>;
  ItemId_gt?: Maybe<ID_Input>;
  ItemId_gte?: Maybe<ID_Input>;
  ItemId_contains?: Maybe<ID_Input>;
  ItemId_not_contains?: Maybe<ID_Input>;
  ItemId_starts_with?: Maybe<ID_Input>;
  ItemId_not_starts_with?: Maybe<ID_Input>;
  ItemId_ends_with?: Maybe<ID_Input>;
  ItemId_not_ends_with?: Maybe<ID_Input>;
  ItemName?: Maybe<String>;
  ItemName_not?: Maybe<String>;
  ItemName_in?: Maybe<String[] | String>;
  ItemName_not_in?: Maybe<String[] | String>;
  ItemName_lt?: Maybe<String>;
  ItemName_lte?: Maybe<String>;
  ItemName_gt?: Maybe<String>;
  ItemName_gte?: Maybe<String>;
  ItemName_contains?: Maybe<String>;
  ItemName_not_contains?: Maybe<String>;
  ItemName_starts_with?: Maybe<String>;
  ItemName_not_starts_with?: Maybe<String>;
  ItemName_ends_with?: Maybe<String>;
  ItemName_not_ends_with?: Maybe<String>;
  Category?: Maybe<String>;
  Category_not?: Maybe<String>;
  Category_in?: Maybe<String[] | String>;
  Category_not_in?: Maybe<String[] | String>;
  Category_lt?: Maybe<String>;
  Category_lte?: Maybe<String>;
  Category_gt?: Maybe<String>;
  Category_gte?: Maybe<String>;
  Category_contains?: Maybe<String>;
  Category_not_contains?: Maybe<String>;
  Category_starts_with?: Maybe<String>;
  Category_not_starts_with?: Maybe<String>;
  Category_ends_with?: Maybe<String>;
  Category_not_ends_with?: Maybe<String>;
  Price?: Maybe<Int>;
  Price_not?: Maybe<Int>;
  Price_in?: Maybe<Int[] | Int>;
  Price_not_in?: Maybe<Int[] | Int>;
  Price_lt?: Maybe<Int>;
  Price_lte?: Maybe<Int>;
  Price_gt?: Maybe<Int>;
  Price_gte?: Maybe<Int>;
  Stock?: Maybe<Int>;
  Stock_not?: Maybe<Int>;
  Stock_in?: Maybe<Int[] | Int>;
  Stock_not_in?: Maybe<Int[] | Int>;
  Stock_lt?: Maybe<Int>;
  Stock_lte?: Maybe<Int>;
  Stock_gt?: Maybe<Int>;
  Stock_gte?: Maybe<Int>;
  Brand?: Maybe<String>;
  Brand_not?: Maybe<String>;
  Brand_in?: Maybe<String[] | String>;
  Brand_not_in?: Maybe<String[] | String>;
  Brand_lt?: Maybe<String>;
  Brand_lte?: Maybe<String>;
  Brand_gt?: Maybe<String>;
  Brand_gte?: Maybe<String>;
  Brand_contains?: Maybe<String>;
  Brand_not_contains?: Maybe<String>;
  Brand_starts_with?: Maybe<String>;
  Brand_not_starts_with?: Maybe<String>;
  Brand_ends_with?: Maybe<String>;
  Brand_not_ends_with?: Maybe<String>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface StaffCreateOneInput {
  create?: Maybe<StaffCreateInput>;
  connect?: Maybe<StaffWhereUniqueInput>;
}

export interface StaffUpsertNestedInput {
  update: StaffUpdateDataInput;
  create: StaffCreateInput;
}

export interface LeaveDayCreateInput {
  LeaveID?: Maybe<ID_Input>;
  StaffMember: StaffCreateOneInput;
  Day?: Maybe<Int>;
  Month?: Maybe<Int>;
  Year?: Maybe<Int>;
}

export interface DepartmentUpsertNestedInput {
  update: DepartmentUpdateDataInput;
  create: DepartmentCreateInput;
}

export type StaffWhereUniqueInput = AtLeastOne<{
  employeeID: Maybe<ID_Input>;
  employeeName?: Maybe<String>;
  nicNumber?: Maybe<String>;
}>;

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PositionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PositionWhereInput>;
  AND?: Maybe<
    PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput
  >;
  OR?: Maybe<PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput>;
  NOT?: Maybe<
    PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput
  >;
}

export interface PositionUpdateDataInput {
  department?: Maybe<DepartmentUpdateOneRequiredInput>;
  basicSalary?: Maybe<Float>;
  otRate?: Maybe<Float>;
  jobRole?: Maybe<String>;
  contractBasis?: Maybe<Boolean>;
  PerContractPrice?: Maybe<Float>;
}

export interface ItemUpdateManyMutationInput {
  ItemName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Int>;
  Stock?: Maybe<Int>;
  Brand?: Maybe<String>;
}

export interface StaffWhereInput {
  employeeID?: Maybe<ID_Input>;
  employeeID_not?: Maybe<ID_Input>;
  employeeID_in?: Maybe<ID_Input[] | ID_Input>;
  employeeID_not_in?: Maybe<ID_Input[] | ID_Input>;
  employeeID_lt?: Maybe<ID_Input>;
  employeeID_lte?: Maybe<ID_Input>;
  employeeID_gt?: Maybe<ID_Input>;
  employeeID_gte?: Maybe<ID_Input>;
  employeeID_contains?: Maybe<ID_Input>;
  employeeID_not_contains?: Maybe<ID_Input>;
  employeeID_starts_with?: Maybe<ID_Input>;
  employeeID_not_starts_with?: Maybe<ID_Input>;
  employeeID_ends_with?: Maybe<ID_Input>;
  employeeID_not_ends_with?: Maybe<ID_Input>;
  employeeName?: Maybe<String>;
  employeeName_not?: Maybe<String>;
  employeeName_in?: Maybe<String[] | String>;
  employeeName_not_in?: Maybe<String[] | String>;
  employeeName_lt?: Maybe<String>;
  employeeName_lte?: Maybe<String>;
  employeeName_gt?: Maybe<String>;
  employeeName_gte?: Maybe<String>;
  employeeName_contains?: Maybe<String>;
  employeeName_not_contains?: Maybe<String>;
  employeeName_starts_with?: Maybe<String>;
  employeeName_not_starts_with?: Maybe<String>;
  employeeName_ends_with?: Maybe<String>;
  employeeName_not_ends_with?: Maybe<String>;
  nicNumber?: Maybe<String>;
  nicNumber_not?: Maybe<String>;
  nicNumber_in?: Maybe<String[] | String>;
  nicNumber_not_in?: Maybe<String[] | String>;
  nicNumber_lt?: Maybe<String>;
  nicNumber_lte?: Maybe<String>;
  nicNumber_gt?: Maybe<String>;
  nicNumber_gte?: Maybe<String>;
  nicNumber_contains?: Maybe<String>;
  nicNumber_not_contains?: Maybe<String>;
  nicNumber_starts_with?: Maybe<String>;
  nicNumber_not_starts_with?: Maybe<String>;
  nicNumber_ends_with?: Maybe<String>;
  nicNumber_not_ends_with?: Maybe<String>;
  bankAccountNumber?: Maybe<String>;
  bankAccountNumber_not?: Maybe<String>;
  bankAccountNumber_in?: Maybe<String[] | String>;
  bankAccountNumber_not_in?: Maybe<String[] | String>;
  bankAccountNumber_lt?: Maybe<String>;
  bankAccountNumber_lte?: Maybe<String>;
  bankAccountNumber_gt?: Maybe<String>;
  bankAccountNumber_gte?: Maybe<String>;
  bankAccountNumber_contains?: Maybe<String>;
  bankAccountNumber_not_contains?: Maybe<String>;
  bankAccountNumber_starts_with?: Maybe<String>;
  bankAccountNumber_not_starts_with?: Maybe<String>;
  bankAccountNumber_ends_with?: Maybe<String>;
  bankAccountNumber_not_ends_with?: Maybe<String>;
  position?: Maybe<PositionWhereInput>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  workEmail?: Maybe<String>;
  workEmail_not?: Maybe<String>;
  workEmail_in?: Maybe<String[] | String>;
  workEmail_not_in?: Maybe<String[] | String>;
  workEmail_lt?: Maybe<String>;
  workEmail_lte?: Maybe<String>;
  workEmail_gt?: Maybe<String>;
  workEmail_gte?: Maybe<String>;
  workEmail_contains?: Maybe<String>;
  workEmail_not_contains?: Maybe<String>;
  workEmail_starts_with?: Maybe<String>;
  workEmail_not_starts_with?: Maybe<String>;
  workEmail_ends_with?: Maybe<String>;
  workEmail_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  Age?: Maybe<Int>;
  Age_not?: Maybe<Int>;
  Age_in?: Maybe<Int[] | Int>;
  Age_not_in?: Maybe<Int[] | Int>;
  Age_lt?: Maybe<Int>;
  Age_lte?: Maybe<Int>;
  Age_gt?: Maybe<Int>;
  Age_gte?: Maybe<Int>;
  AND?: Maybe<StaffWhereInput[] | StaffWhereInput>;
  OR?: Maybe<StaffWhereInput[] | StaffWhereInput>;
  NOT?: Maybe<StaffWhereInput[] | StaffWhereInput>;
}

export interface ItemUpdateInput {
  ItemName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Int>;
  Stock?: Maybe<Int>;
  Brand?: Maybe<String>;
}

export interface LeaveDaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LeaveDayWhereInput>;
  AND?: Maybe<
    LeaveDaySubscriptionWhereInput[] | LeaveDaySubscriptionWhereInput
  >;
  OR?: Maybe<LeaveDaySubscriptionWhereInput[] | LeaveDaySubscriptionWhereInput>;
  NOT?: Maybe<
    LeaveDaySubscriptionWhereInput[] | LeaveDaySubscriptionWhereInput
  >;
}

export interface ItemCreateInput {
  ItemId?: Maybe<ID_Input>;
  ItemName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Int>;
  Stock?: Maybe<Int>;
  Brand?: Maybe<String>;
}

export interface CardTemplateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CardTemplateWhereInput>;
  AND?: Maybe<
    CardTemplateSubscriptionWhereInput[] | CardTemplateSubscriptionWhereInput
  >;
  OR?: Maybe<
    CardTemplateSubscriptionWhereInput[] | CardTemplateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CardTemplateSubscriptionWhereInput[] | CardTemplateSubscriptionWhereInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  reset?: Maybe<String>;
}

export interface EventPackageUpdateManyMutationInput {
  PackageName?: Maybe<String>;
  BookingCost?: Maybe<Int>;
  FoodPackage?: Maybe<String>;
  PhotographyServices?: Maybe<String>;
  Sounds?: Maybe<String>;
}

export interface StaffUpdateInput {
  employeeName?: Maybe<String>;
  nicNumber?: Maybe<String>;
  bankAccountNumber?: Maybe<String>;
  position?: Maybe<PositionUpdateOneInput>;
  address?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  workEmail?: Maybe<String>;
  password?: Maybe<String>;
  Age?: Maybe<Int>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  reset?: Maybe<String>;
  reset_not?: Maybe<String>;
  reset_in?: Maybe<String[] | String>;
  reset_not_in?: Maybe<String[] | String>;
  reset_lt?: Maybe<String>;
  reset_lte?: Maybe<String>;
  reset_gt?: Maybe<String>;
  reset_gte?: Maybe<String>;
  reset_contains?: Maybe<String>;
  reset_not_contains?: Maybe<String>;
  reset_starts_with?: Maybe<String>;
  reset_not_starts_with?: Maybe<String>;
  reset_ends_with?: Maybe<String>;
  reset_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface EventPackageWhereInput {
  PackageID?: Maybe<ID_Input>;
  PackageID_not?: Maybe<ID_Input>;
  PackageID_in?: Maybe<ID_Input[] | ID_Input>;
  PackageID_not_in?: Maybe<ID_Input[] | ID_Input>;
  PackageID_lt?: Maybe<ID_Input>;
  PackageID_lte?: Maybe<ID_Input>;
  PackageID_gt?: Maybe<ID_Input>;
  PackageID_gte?: Maybe<ID_Input>;
  PackageID_contains?: Maybe<ID_Input>;
  PackageID_not_contains?: Maybe<ID_Input>;
  PackageID_starts_with?: Maybe<ID_Input>;
  PackageID_not_starts_with?: Maybe<ID_Input>;
  PackageID_ends_with?: Maybe<ID_Input>;
  PackageID_not_ends_with?: Maybe<ID_Input>;
  PackageName?: Maybe<String>;
  PackageName_not?: Maybe<String>;
  PackageName_in?: Maybe<String[] | String>;
  PackageName_not_in?: Maybe<String[] | String>;
  PackageName_lt?: Maybe<String>;
  PackageName_lte?: Maybe<String>;
  PackageName_gt?: Maybe<String>;
  PackageName_gte?: Maybe<String>;
  PackageName_contains?: Maybe<String>;
  PackageName_not_contains?: Maybe<String>;
  PackageName_starts_with?: Maybe<String>;
  PackageName_not_starts_with?: Maybe<String>;
  PackageName_ends_with?: Maybe<String>;
  PackageName_not_ends_with?: Maybe<String>;
  BookingCost?: Maybe<Int>;
  BookingCost_not?: Maybe<Int>;
  BookingCost_in?: Maybe<Int[] | Int>;
  BookingCost_not_in?: Maybe<Int[] | Int>;
  BookingCost_lt?: Maybe<Int>;
  BookingCost_lte?: Maybe<Int>;
  BookingCost_gt?: Maybe<Int>;
  BookingCost_gte?: Maybe<Int>;
  FoodPackage?: Maybe<String>;
  FoodPackage_not?: Maybe<String>;
  FoodPackage_in?: Maybe<String[] | String>;
  FoodPackage_not_in?: Maybe<String[] | String>;
  FoodPackage_lt?: Maybe<String>;
  FoodPackage_lte?: Maybe<String>;
  FoodPackage_gt?: Maybe<String>;
  FoodPackage_gte?: Maybe<String>;
  FoodPackage_contains?: Maybe<String>;
  FoodPackage_not_contains?: Maybe<String>;
  FoodPackage_starts_with?: Maybe<String>;
  FoodPackage_not_starts_with?: Maybe<String>;
  FoodPackage_ends_with?: Maybe<String>;
  FoodPackage_not_ends_with?: Maybe<String>;
  PhotographyServices?: Maybe<String>;
  PhotographyServices_not?: Maybe<String>;
  PhotographyServices_in?: Maybe<String[] | String>;
  PhotographyServices_not_in?: Maybe<String[] | String>;
  PhotographyServices_lt?: Maybe<String>;
  PhotographyServices_lte?: Maybe<String>;
  PhotographyServices_gt?: Maybe<String>;
  PhotographyServices_gte?: Maybe<String>;
  PhotographyServices_contains?: Maybe<String>;
  PhotographyServices_not_contains?: Maybe<String>;
  PhotographyServices_starts_with?: Maybe<String>;
  PhotographyServices_not_starts_with?: Maybe<String>;
  PhotographyServices_ends_with?: Maybe<String>;
  PhotographyServices_not_ends_with?: Maybe<String>;
  Sounds?: Maybe<String>;
  Sounds_not?: Maybe<String>;
  Sounds_in?: Maybe<String[] | String>;
  Sounds_not_in?: Maybe<String[] | String>;
  Sounds_lt?: Maybe<String>;
  Sounds_lte?: Maybe<String>;
  Sounds_gt?: Maybe<String>;
  Sounds_gte?: Maybe<String>;
  Sounds_contains?: Maybe<String>;
  Sounds_not_contains?: Maybe<String>;
  Sounds_starts_with?: Maybe<String>;
  Sounds_not_starts_with?: Maybe<String>;
  Sounds_ends_with?: Maybe<String>;
  Sounds_not_ends_with?: Maybe<String>;
  AND?: Maybe<EventPackageWhereInput[] | EventPackageWhereInput>;
  OR?: Maybe<EventPackageWhereInput[] | EventPackageWhereInput>;
  NOT?: Maybe<EventPackageWhereInput[] | EventPackageWhereInput>;
}

export interface StaffSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StaffWhereInput>;
  AND?: Maybe<StaffSubscriptionWhereInput[] | StaffSubscriptionWhereInput>;
  OR?: Maybe<StaffSubscriptionWhereInput[] | StaffSubscriptionWhereInput>;
  NOT?: Maybe<StaffSubscriptionWhereInput[] | StaffSubscriptionWhereInput>;
}

export interface PhotoFrameTemplateCreateInput {
  FrameID?: Maybe<ID_Input>;
  FrameName?: Maybe<String>;
  FrameMaterial?: Maybe<String>;
  PhotoFinish?: Maybe<String>;
  Price?: Maybe<Int>;
  Dimensions?: Maybe<String>;
}

export interface EventPackageUpdateInput {
  PackageName?: Maybe<String>;
  BookingCost?: Maybe<Int>;
  FoodPackage?: Maybe<String>;
  PhotographyServices?: Maybe<String>;
  Sounds?: Maybe<String>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface EventPackageCreateInput {
  PackageID?: Maybe<ID_Input>;
  PackageName?: Maybe<String>;
  BookingCost?: Maybe<Int>;
  FoodPackage?: Maybe<String>;
  PhotographyServices?: Maybe<String>;
  Sounds?: Maybe<String>;
}

export type LeaveDayWhereUniqueInput = AtLeastOne<{
  LeaveID: Maybe<ID_Input>;
}>;

export interface DepartmentUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface LeaveDayWhereInput {
  LeaveID?: Maybe<ID_Input>;
  LeaveID_not?: Maybe<ID_Input>;
  LeaveID_in?: Maybe<ID_Input[] | ID_Input>;
  LeaveID_not_in?: Maybe<ID_Input[] | ID_Input>;
  LeaveID_lt?: Maybe<ID_Input>;
  LeaveID_lte?: Maybe<ID_Input>;
  LeaveID_gt?: Maybe<ID_Input>;
  LeaveID_gte?: Maybe<ID_Input>;
  LeaveID_contains?: Maybe<ID_Input>;
  LeaveID_not_contains?: Maybe<ID_Input>;
  LeaveID_starts_with?: Maybe<ID_Input>;
  LeaveID_not_starts_with?: Maybe<ID_Input>;
  LeaveID_ends_with?: Maybe<ID_Input>;
  LeaveID_not_ends_with?: Maybe<ID_Input>;
  StaffMember?: Maybe<StaffWhereInput>;
  Day?: Maybe<Int>;
  Day_not?: Maybe<Int>;
  Day_in?: Maybe<Int[] | Int>;
  Day_not_in?: Maybe<Int[] | Int>;
  Day_lt?: Maybe<Int>;
  Day_lte?: Maybe<Int>;
  Day_gt?: Maybe<Int>;
  Day_gte?: Maybe<Int>;
  Month?: Maybe<Int>;
  Month_not?: Maybe<Int>;
  Month_in?: Maybe<Int[] | Int>;
  Month_not_in?: Maybe<Int[] | Int>;
  Month_lt?: Maybe<Int>;
  Month_lte?: Maybe<Int>;
  Month_gt?: Maybe<Int>;
  Month_gte?: Maybe<Int>;
  Year?: Maybe<Int>;
  Year_not?: Maybe<Int>;
  Year_in?: Maybe<Int[] | Int>;
  Year_not_in?: Maybe<Int[] | Int>;
  Year_lt?: Maybe<Int>;
  Year_lte?: Maybe<Int>;
  Year_gt?: Maybe<Int>;
  Year_gte?: Maybe<Int>;
  AND?: Maybe<LeaveDayWhereInput[] | LeaveDayWhereInput>;
  OR?: Maybe<LeaveDayWhereInput[] | LeaveDayWhereInput>;
  NOT?: Maybe<LeaveDayWhereInput[] | LeaveDayWhereInput>;
}

export interface DepartmentUpdateInput {
  name?: Maybe<String>;
}

export interface CustomerWhereInput {
  CustomerID?: Maybe<ID_Input>;
  CustomerID_not?: Maybe<ID_Input>;
  CustomerID_in?: Maybe<ID_Input[] | ID_Input>;
  CustomerID_not_in?: Maybe<ID_Input[] | ID_Input>;
  CustomerID_lt?: Maybe<ID_Input>;
  CustomerID_lte?: Maybe<ID_Input>;
  CustomerID_gt?: Maybe<ID_Input>;
  CustomerID_gte?: Maybe<ID_Input>;
  CustomerID_contains?: Maybe<ID_Input>;
  CustomerID_not_contains?: Maybe<ID_Input>;
  CustomerID_starts_with?: Maybe<ID_Input>;
  CustomerID_not_starts_with?: Maybe<ID_Input>;
  CustomerID_ends_with?: Maybe<ID_Input>;
  CustomerID_not_ends_with?: Maybe<ID_Input>;
  CustomerName?: Maybe<String>;
  CustomerName_not?: Maybe<String>;
  CustomerName_in?: Maybe<String[] | String>;
  CustomerName_not_in?: Maybe<String[] | String>;
  CustomerName_lt?: Maybe<String>;
  CustomerName_lte?: Maybe<String>;
  CustomerName_gt?: Maybe<String>;
  CustomerName_gte?: Maybe<String>;
  CustomerName_contains?: Maybe<String>;
  CustomerName_not_contains?: Maybe<String>;
  CustomerName_starts_with?: Maybe<String>;
  CustomerName_not_starts_with?: Maybe<String>;
  CustomerName_ends_with?: Maybe<String>;
  CustomerName_not_ends_with?: Maybe<String>;
  Address?: Maybe<String>;
  Address_not?: Maybe<String>;
  Address_in?: Maybe<String[] | String>;
  Address_not_in?: Maybe<String[] | String>;
  Address_lt?: Maybe<String>;
  Address_lte?: Maybe<String>;
  Address_gt?: Maybe<String>;
  Address_gte?: Maybe<String>;
  Address_contains?: Maybe<String>;
  Address_not_contains?: Maybe<String>;
  Address_starts_with?: Maybe<String>;
  Address_not_starts_with?: Maybe<String>;
  Address_ends_with?: Maybe<String>;
  Address_not_ends_with?: Maybe<String>;
  Gender?: Maybe<String>;
  Gender_not?: Maybe<String>;
  Gender_in?: Maybe<String[] | String>;
  Gender_not_in?: Maybe<String[] | String>;
  Gender_lt?: Maybe<String>;
  Gender_lte?: Maybe<String>;
  Gender_gt?: Maybe<String>;
  Gender_gte?: Maybe<String>;
  Gender_contains?: Maybe<String>;
  Gender_not_contains?: Maybe<String>;
  Gender_starts_with?: Maybe<String>;
  Gender_not_starts_with?: Maybe<String>;
  Gender_ends_with?: Maybe<String>;
  Gender_not_ends_with?: Maybe<String>;
  Phone?: Maybe<Int>;
  Phone_not?: Maybe<Int>;
  Phone_in?: Maybe<Int[] | Int>;
  Phone_not_in?: Maybe<Int[] | Int>;
  Phone_lt?: Maybe<Int>;
  Phone_lte?: Maybe<Int>;
  Phone_gt?: Maybe<Int>;
  Phone_gte?: Maybe<Int>;
  CustomerEmail?: Maybe<String>;
  CustomerEmail_not?: Maybe<String>;
  CustomerEmail_in?: Maybe<String[] | String>;
  CustomerEmail_not_in?: Maybe<String[] | String>;
  CustomerEmail_lt?: Maybe<String>;
  CustomerEmail_lte?: Maybe<String>;
  CustomerEmail_gt?: Maybe<String>;
  CustomerEmail_gte?: Maybe<String>;
  CustomerEmail_contains?: Maybe<String>;
  CustomerEmail_not_contains?: Maybe<String>;
  CustomerEmail_starts_with?: Maybe<String>;
  CustomerEmail_not_starts_with?: Maybe<String>;
  CustomerEmail_ends_with?: Maybe<String>;
  CustomerEmail_not_ends_with?: Maybe<String>;
  Ethnicity?: Maybe<String>;
  Ethnicity_not?: Maybe<String>;
  Ethnicity_in?: Maybe<String[] | String>;
  Ethnicity_not_in?: Maybe<String[] | String>;
  Ethnicity_lt?: Maybe<String>;
  Ethnicity_lte?: Maybe<String>;
  Ethnicity_gt?: Maybe<String>;
  Ethnicity_gte?: Maybe<String>;
  Ethnicity_contains?: Maybe<String>;
  Ethnicity_not_contains?: Maybe<String>;
  Ethnicity_starts_with?: Maybe<String>;
  Ethnicity_not_starts_with?: Maybe<String>;
  Ethnicity_ends_with?: Maybe<String>;
  Ethnicity_not_ends_with?: Maybe<String>;
  LoyalityPoints?: Maybe<Float>;
  LoyalityPoints_not?: Maybe<Float>;
  LoyalityPoints_in?: Maybe<Float[] | Float>;
  LoyalityPoints_not_in?: Maybe<Float[] | Float>;
  LoyalityPoints_lt?: Maybe<Float>;
  LoyalityPoints_lte?: Maybe<Float>;
  LoyalityPoints_gt?: Maybe<Float>;
  LoyalityPoints_gte?: Maybe<Float>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface CardTemplateCreateInput {
  CardId?: Maybe<ID_Input>;
  CardName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Float>;
  Size?: Maybe<String>;
  Material?: Maybe<String>;
  SearchTags?: Maybe<String>;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DepartmentWhereInput>;
  AND?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  OR?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput
  >;
}

export interface CardTemplateUpdateInput {
  CardName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Float>;
  Size?: Maybe<String>;
  Material?: Maybe<String>;
  SearchTags?: Maybe<String>;
}

export interface PhotoFrameTemplateUpdateManyMutationInput {
  FrameName?: Maybe<String>;
  FrameMaterial?: Maybe<String>;
  PhotoFinish?: Maybe<String>;
  Price?: Maybe<Int>;
  Dimensions?: Maybe<String>;
}

export interface PositionUpsertNestedInput {
  update: PositionUpdateDataInput;
  create: PositionCreateInput;
}

export interface CustomerCreateInput {
  CustomerID?: Maybe<ID_Input>;
  CustomerName?: Maybe<String>;
  Address?: Maybe<String>;
  Gender?: Maybe<String>;
  Phone?: Maybe<Int>;
  CustomerEmail?: Maybe<String>;
  Ethnicity?: Maybe<String>;
  LoyalityPoints?: Maybe<Float>;
}

export interface CustomerUpdateManyMutationInput {
  CustomerName?: Maybe<String>;
  Address?: Maybe<String>;
  Gender?: Maybe<String>;
  Phone?: Maybe<Int>;
  CustomerEmail?: Maybe<String>;
  Ethnicity?: Maybe<String>;
  LoyalityPoints?: Maybe<Float>;
}

export interface DepartmentCreateInput {
  departmentID?: Maybe<ID_Input>;
  name: String;
}

export interface CardTemplateUpdateManyMutationInput {
  CardName?: Maybe<String>;
  Category?: Maybe<String>;
  Price?: Maybe<Float>;
  Size?: Maybe<String>;
  Material?: Maybe<String>;
  SearchTags?: Maybe<String>;
}

export interface DepartmentUpdateOneRequiredInput {
  create?: Maybe<DepartmentCreateInput>;
  update?: Maybe<DepartmentUpdateDataInput>;
  upsert?: Maybe<DepartmentUpsertNestedInput>;
  connect?: Maybe<DepartmentWhereUniqueInput>;
}

export interface LeaveDayUpdateManyMutationInput {
  Day?: Maybe<Int>;
  Month?: Maybe<Int>;
  Year?: Maybe<Int>;
}

export type EventPackageWhereUniqueInput = AtLeastOne<{
  PackageID: Maybe<ID_Input>;
}>;

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  reset?: Maybe<String>;
}

export interface PositionWhereInput {
  positionId?: Maybe<ID_Input>;
  positionId_not?: Maybe<ID_Input>;
  positionId_in?: Maybe<ID_Input[] | ID_Input>;
  positionId_not_in?: Maybe<ID_Input[] | ID_Input>;
  positionId_lt?: Maybe<ID_Input>;
  positionId_lte?: Maybe<ID_Input>;
  positionId_gt?: Maybe<ID_Input>;
  positionId_gte?: Maybe<ID_Input>;
  positionId_contains?: Maybe<ID_Input>;
  positionId_not_contains?: Maybe<ID_Input>;
  positionId_starts_with?: Maybe<ID_Input>;
  positionId_not_starts_with?: Maybe<ID_Input>;
  positionId_ends_with?: Maybe<ID_Input>;
  positionId_not_ends_with?: Maybe<ID_Input>;
  department?: Maybe<DepartmentWhereInput>;
  basicSalary?: Maybe<Float>;
  basicSalary_not?: Maybe<Float>;
  basicSalary_in?: Maybe<Float[] | Float>;
  basicSalary_not_in?: Maybe<Float[] | Float>;
  basicSalary_lt?: Maybe<Float>;
  basicSalary_lte?: Maybe<Float>;
  basicSalary_gt?: Maybe<Float>;
  basicSalary_gte?: Maybe<Float>;
  otRate?: Maybe<Float>;
  otRate_not?: Maybe<Float>;
  otRate_in?: Maybe<Float[] | Float>;
  otRate_not_in?: Maybe<Float[] | Float>;
  otRate_lt?: Maybe<Float>;
  otRate_lte?: Maybe<Float>;
  otRate_gt?: Maybe<Float>;
  otRate_gte?: Maybe<Float>;
  jobRole?: Maybe<String>;
  jobRole_not?: Maybe<String>;
  jobRole_in?: Maybe<String[] | String>;
  jobRole_not_in?: Maybe<String[] | String>;
  jobRole_lt?: Maybe<String>;
  jobRole_lte?: Maybe<String>;
  jobRole_gt?: Maybe<String>;
  jobRole_gte?: Maybe<String>;
  jobRole_contains?: Maybe<String>;
  jobRole_not_contains?: Maybe<String>;
  jobRole_starts_with?: Maybe<String>;
  jobRole_not_starts_with?: Maybe<String>;
  jobRole_ends_with?: Maybe<String>;
  jobRole_not_ends_with?: Maybe<String>;
  contractBasis?: Maybe<Boolean>;
  contractBasis_not?: Maybe<Boolean>;
  PerContractPrice?: Maybe<Float>;
  PerContractPrice_not?: Maybe<Float>;
  PerContractPrice_in?: Maybe<Float[] | Float>;
  PerContractPrice_not_in?: Maybe<Float[] | Float>;
  PerContractPrice_lt?: Maybe<Float>;
  PerContractPrice_lte?: Maybe<Float>;
  PerContractPrice_gt?: Maybe<Float>;
  PerContractPrice_gte?: Maybe<Float>;
  AND?: Maybe<PositionWhereInput[] | PositionWhereInput>;
  OR?: Maybe<PositionWhereInput[] | PositionWhereInput>;
  NOT?: Maybe<PositionWhereInput[] | PositionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Department {
  departmentID: ID_Output;
  name: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  departmentID: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  departmentID: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentNullablePromise
  extends Promise<Department | null>,
    Fragmentable {
  departmentID: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  reset?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  reset: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  reset: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentConnection {
  pageInfo: PageInfo;
  edges: DepartmentEdge[];
}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartmentPromise>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface CardTemplate {
  CardId: ID_Output;
  CardName?: String;
  Category?: String;
  Price?: Float;
  Size?: String;
  Material?: String;
  SearchTags?: String;
}

export interface CardTemplatePromise
  extends Promise<CardTemplate>,
    Fragmentable {
  CardId: () => Promise<ID_Output>;
  CardName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Float>;
  Size: () => Promise<String>;
  Material: () => Promise<String>;
  SearchTags: () => Promise<String>;
}

export interface CardTemplateSubscription
  extends Promise<AsyncIterator<CardTemplate>>,
    Fragmentable {
  CardId: () => Promise<AsyncIterator<ID_Output>>;
  CardName: () => Promise<AsyncIterator<String>>;
  Category: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Float>>;
  Size: () => Promise<AsyncIterator<String>>;
  Material: () => Promise<AsyncIterator<String>>;
  SearchTags: () => Promise<AsyncIterator<String>>;
}

export interface CardTemplateNullablePromise
  extends Promise<CardTemplate | null>,
    Fragmentable {
  CardId: () => Promise<ID_Output>;
  CardName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Float>;
  Size: () => Promise<String>;
  Material: () => Promise<String>;
  SearchTags: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStaff {
  count: Int;
}

export interface AggregateStaffPromise
  extends Promise<AggregateStaff>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStaffSubscription
  extends Promise<AsyncIterator<AggregateStaff>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface StaffConnection {
  pageInfo: PageInfo;
  edges: StaffEdge[];
}

export interface StaffConnectionPromise
  extends Promise<StaffConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StaffEdge>>() => T;
  aggregate: <T = AggregateStaffPromise>() => T;
}

export interface StaffConnectionSubscription
  extends Promise<AsyncIterator<StaffConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StaffEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStaffSubscription>() => T;
}

export interface Customer {
  CustomerID: ID_Output;
  CustomerName?: String;
  Address?: String;
  Gender?: String;
  Phone?: Int;
  CustomerEmail?: String;
  Ethnicity?: String;
  LoyalityPoints?: Float;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  CustomerID: () => Promise<ID_Output>;
  CustomerName: () => Promise<String>;
  Address: () => Promise<String>;
  Gender: () => Promise<String>;
  Phone: () => Promise<Int>;
  CustomerEmail: () => Promise<String>;
  Ethnicity: () => Promise<String>;
  LoyalityPoints: () => Promise<Float>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  CustomerID: () => Promise<AsyncIterator<ID_Output>>;
  CustomerName: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<String>>;
  Phone: () => Promise<AsyncIterator<Int>>;
  CustomerEmail: () => Promise<AsyncIterator<String>>;
  Ethnicity: () => Promise<AsyncIterator<String>>;
  LoyalityPoints: () => Promise<AsyncIterator<Float>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  CustomerID: () => Promise<ID_Output>;
  CustomerName: () => Promise<String>;
  Address: () => Promise<String>;
  Gender: () => Promise<String>;
  Phone: () => Promise<Int>;
  CustomerEmail: () => Promise<String>;
  Ethnicity: () => Promise<String>;
  LoyalityPoints: () => Promise<Float>;
}

export interface PositionEdge {
  node: Position;
  cursor: String;
}

export interface PositionEdgePromise
  extends Promise<PositionEdge>,
    Fragmentable {
  node: <T = PositionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PositionEdgeSubscription
  extends Promise<AsyncIterator<PositionEdge>>,
    Fragmentable {
  node: <T = PositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CardTemplateSubscriptionPayload {
  mutation: MutationType;
  node: CardTemplate;
  updatedFields: String[];
  previousValues: CardTemplatePreviousValues;
}

export interface CardTemplateSubscriptionPayloadPromise
  extends Promise<CardTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CardTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CardTemplatePreviousValuesPromise>() => T;
}

export interface CardTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CardTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CardTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CardTemplatePreviousValuesSubscription>() => T;
}

export interface AggregatePhotoFrameTemplate {
  count: Int;
}

export interface AggregatePhotoFrameTemplatePromise
  extends Promise<AggregatePhotoFrameTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoFrameTemplateSubscription
  extends Promise<AsyncIterator<AggregatePhotoFrameTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CardTemplatePreviousValues {
  CardId: ID_Output;
  CardName?: String;
  Category?: String;
  Price?: Float;
  Size?: String;
  Material?: String;
  SearchTags?: String;
}

export interface CardTemplatePreviousValuesPromise
  extends Promise<CardTemplatePreviousValues>,
    Fragmentable {
  CardId: () => Promise<ID_Output>;
  CardName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Float>;
  Size: () => Promise<String>;
  Material: () => Promise<String>;
  SearchTags: () => Promise<String>;
}

export interface CardTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<CardTemplatePreviousValues>>,
    Fragmentable {
  CardId: () => Promise<AsyncIterator<ID_Output>>;
  CardName: () => Promise<AsyncIterator<String>>;
  Category: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Float>>;
  Size: () => Promise<AsyncIterator<String>>;
  Material: () => Promise<AsyncIterator<String>>;
  SearchTags: () => Promise<AsyncIterator<String>>;
}

export interface PhotoFrameTemplateConnection {
  pageInfo: PageInfo;
  edges: PhotoFrameTemplateEdge[];
}

export interface PhotoFrameTemplateConnectionPromise
  extends Promise<PhotoFrameTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoFrameTemplateEdge>>() => T;
  aggregate: <T = AggregatePhotoFrameTemplatePromise>() => T;
}

export interface PhotoFrameTemplateConnectionSubscription
  extends Promise<AsyncIterator<PhotoFrameTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<PhotoFrameTemplateEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregatePhotoFrameTemplateSubscription>() => T;
}

export interface AggregateCardTemplate {
  count: Int;
}

export interface AggregateCardTemplatePromise
  extends Promise<AggregateCardTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCardTemplateSubscription
  extends Promise<AsyncIterator<AggregateCardTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLeaveDay {
  count: Int;
}

export interface AggregateLeaveDayPromise
  extends Promise<AggregateLeaveDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeaveDaySubscription
  extends Promise<AsyncIterator<AggregateLeaveDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface LeaveDayConnection {
  pageInfo: PageInfo;
  edges: LeaveDayEdge[];
}

export interface LeaveDayConnectionPromise
  extends Promise<LeaveDayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeaveDayEdge>>() => T;
  aggregate: <T = AggregateLeaveDayPromise>() => T;
}

export interface LeaveDayConnectionSubscription
  extends Promise<AsyncIterator<LeaveDayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeaveDayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeaveDaySubscription>() => T;
}

export interface CustomerPreviousValues {
  CustomerID: ID_Output;
  CustomerName?: String;
  Address?: String;
  Gender?: String;
  Phone?: Int;
  CustomerEmail?: String;
  Ethnicity?: String;
  LoyalityPoints?: Float;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  CustomerID: () => Promise<ID_Output>;
  CustomerName: () => Promise<String>;
  Address: () => Promise<String>;
  Gender: () => Promise<String>;
  Phone: () => Promise<Int>;
  CustomerEmail: () => Promise<String>;
  Ethnicity: () => Promise<String>;
  LoyalityPoints: () => Promise<Float>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  CustomerID: () => Promise<AsyncIterator<ID_Output>>;
  CustomerName: () => Promise<AsyncIterator<String>>;
  Address: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<String>>;
  Phone: () => Promise<AsyncIterator<Int>>;
  CustomerEmail: () => Promise<AsyncIterator<String>>;
  Ethnicity: () => Promise<AsyncIterator<String>>;
  LoyalityPoints: () => Promise<AsyncIterator<Float>>;
}

export interface Staff {
  employeeID: ID_Output;
  employeeName?: String;
  nicNumber?: String;
  bankAccountNumber?: String;
  address?: String;
  phoneNumber?: String;
  workEmail?: String;
  password?: String;
  Age?: Int;
}

export interface StaffPromise extends Promise<Staff>, Fragmentable {
  employeeID: () => Promise<ID_Output>;
  employeeName: () => Promise<String>;
  nicNumber: () => Promise<String>;
  bankAccountNumber: () => Promise<String>;
  position: <T = PositionPromise>() => T;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  workEmail: () => Promise<String>;
  password: () => Promise<String>;
  Age: () => Promise<Int>;
}

export interface StaffSubscription
  extends Promise<AsyncIterator<Staff>>,
    Fragmentable {
  employeeID: () => Promise<AsyncIterator<ID_Output>>;
  employeeName: () => Promise<AsyncIterator<String>>;
  nicNumber: () => Promise<AsyncIterator<String>>;
  bankAccountNumber: () => Promise<AsyncIterator<String>>;
  position: <T = PositionSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  workEmail: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  Age: () => Promise<AsyncIterator<Int>>;
}

export interface StaffNullablePromise
  extends Promise<Staff | null>,
    Fragmentable {
  employeeID: () => Promise<ID_Output>;
  employeeName: () => Promise<String>;
  nicNumber: () => Promise<String>;
  bankAccountNumber: () => Promise<String>;
  position: <T = PositionPromise>() => T;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  workEmail: () => Promise<String>;
  password: () => Promise<String>;
  Age: () => Promise<Int>;
}

export interface CardTemplateEdge {
  node: CardTemplate;
  cursor: String;
}

export interface CardTemplateEdgePromise
  extends Promise<CardTemplateEdge>,
    Fragmentable {
  node: <T = CardTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CardTemplateEdgeSubscription
  extends Promise<AsyncIterator<CardTemplateEdge>>,
    Fragmentable {
  node: <T = CardTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  node: Department;
  updatedFields: String[];
  previousValues: DepartmentPreviousValues;
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DepartmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValuesPromise>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface DepartmentPreviousValues {
  departmentID: ID_Output;
  name: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  departmentID: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  departmentID: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEventPackage {
  count: Int;
}

export interface AggregateEventPackagePromise
  extends Promise<AggregateEventPackage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventPackageSubscription
  extends Promise<AsyncIterator<AggregateEventPackage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface EventPackageConnection {
  pageInfo: PageInfo;
  edges: EventPackageEdge[];
}

export interface EventPackageConnectionPromise
  extends Promise<EventPackageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventPackageEdge>>() => T;
  aggregate: <T = AggregateEventPackagePromise>() => T;
}

export interface EventPackageConnectionSubscription
  extends Promise<AsyncIterator<EventPackageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventPackageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventPackageSubscription>() => T;
}

export interface EventPackageSubscriptionPayload {
  mutation: MutationType;
  node: EventPackage;
  updatedFields: String[];
  previousValues: EventPackagePreviousValues;
}

export interface EventPackageSubscriptionPayloadPromise
  extends Promise<EventPackageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPackagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPackagePreviousValuesPromise>() => T;
}

export interface EventPackageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventPackageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventPackageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPackagePreviousValuesSubscription>() => T;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventPackagePreviousValues {
  PackageID: ID_Output;
  PackageName?: String;
  BookingCost?: Int;
  FoodPackage?: String;
  PhotographyServices?: String;
  Sounds?: String;
}

export interface EventPackagePreviousValuesPromise
  extends Promise<EventPackagePreviousValues>,
    Fragmentable {
  PackageID: () => Promise<ID_Output>;
  PackageName: () => Promise<String>;
  BookingCost: () => Promise<Int>;
  FoodPackage: () => Promise<String>;
  PhotographyServices: () => Promise<String>;
  Sounds: () => Promise<String>;
}

export interface EventPackagePreviousValuesSubscription
  extends Promise<AsyncIterator<EventPackagePreviousValues>>,
    Fragmentable {
  PackageID: () => Promise<AsyncIterator<ID_Output>>;
  PackageName: () => Promise<AsyncIterator<String>>;
  BookingCost: () => Promise<AsyncIterator<Int>>;
  FoodPackage: () => Promise<AsyncIterator<String>>;
  PhotographyServices: () => Promise<AsyncIterator<String>>;
  Sounds: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface StaffEdge {
  node: Staff;
  cursor: String;
}

export interface StaffEdgePromise extends Promise<StaffEdge>, Fragmentable {
  node: <T = StaffPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StaffEdgeSubscription
  extends Promise<AsyncIterator<StaffEdge>>,
    Fragmentable {
  node: <T = StaffSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface PositionConnection {
  pageInfo: PageInfo;
  edges: PositionEdge[];
}

export interface PositionConnectionPromise
  extends Promise<PositionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PositionEdge>>() => T;
  aggregate: <T = AggregatePositionPromise>() => T;
}

export interface PositionConnectionSubscription
  extends Promise<AsyncIterator<PositionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PositionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePositionSubscription>() => T;
}

export interface ItemPreviousValues {
  ItemId: ID_Output;
  ItemName?: String;
  Category?: String;
  Price?: Int;
  Stock?: Int;
  Brand?: String;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  ItemId: () => Promise<ID_Output>;
  ItemName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Int>;
  Stock: () => Promise<Int>;
  Brand: () => Promise<String>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  ItemId: () => Promise<AsyncIterator<ID_Output>>;
  ItemName: () => Promise<AsyncIterator<String>>;
  Category: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Int>>;
  Stock: () => Promise<AsyncIterator<Int>>;
  Brand: () => Promise<AsyncIterator<String>>;
}

export interface PhotoFrameTemplate {
  FrameID: ID_Output;
  FrameName?: String;
  FrameMaterial?: String;
  PhotoFinish?: String;
  Price?: Int;
  Dimensions?: String;
}

export interface PhotoFrameTemplatePromise
  extends Promise<PhotoFrameTemplate>,
    Fragmentable {
  FrameID: () => Promise<ID_Output>;
  FrameName: () => Promise<String>;
  FrameMaterial: () => Promise<String>;
  PhotoFinish: () => Promise<String>;
  Price: () => Promise<Int>;
  Dimensions: () => Promise<String>;
}

export interface PhotoFrameTemplateSubscription
  extends Promise<AsyncIterator<PhotoFrameTemplate>>,
    Fragmentable {
  FrameID: () => Promise<AsyncIterator<ID_Output>>;
  FrameName: () => Promise<AsyncIterator<String>>;
  FrameMaterial: () => Promise<AsyncIterator<String>>;
  PhotoFinish: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Int>>;
  Dimensions: () => Promise<AsyncIterator<String>>;
}

export interface PhotoFrameTemplateNullablePromise
  extends Promise<PhotoFrameTemplate | null>,
    Fragmentable {
  FrameID: () => Promise<ID_Output>;
  FrameName: () => Promise<String>;
  FrameMaterial: () => Promise<String>;
  PhotoFinish: () => Promise<String>;
  Price: () => Promise<Int>;
  Dimensions: () => Promise<String>;
}

export interface CardTemplateConnection {
  pageInfo: PageInfo;
  edges: CardTemplateEdge[];
}

export interface CardTemplateConnectionPromise
  extends Promise<CardTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CardTemplateEdge>>() => T;
  aggregate: <T = AggregateCardTemplatePromise>() => T;
}

export interface CardTemplateConnectionSubscription
  extends Promise<AsyncIterator<CardTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CardTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCardTemplateSubscription>() => T;
}

export interface Position {
  positionId: ID_Output;
  basicSalary?: Float;
  otRate?: Float;
  jobRole?: String;
  contractBasis?: Boolean;
  PerContractPrice?: Float;
}

export interface PositionPromise extends Promise<Position>, Fragmentable {
  positionId: () => Promise<ID_Output>;
  department: <T = DepartmentPromise>() => T;
  basicSalary: () => Promise<Float>;
  otRate: () => Promise<Float>;
  jobRole: () => Promise<String>;
  contractBasis: () => Promise<Boolean>;
  PerContractPrice: () => Promise<Float>;
}

export interface PositionSubscription
  extends Promise<AsyncIterator<Position>>,
    Fragmentable {
  positionId: () => Promise<AsyncIterator<ID_Output>>;
  department: <T = DepartmentSubscription>() => T;
  basicSalary: () => Promise<AsyncIterator<Float>>;
  otRate: () => Promise<AsyncIterator<Float>>;
  jobRole: () => Promise<AsyncIterator<String>>;
  contractBasis: () => Promise<AsyncIterator<Boolean>>;
  PerContractPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PositionNullablePromise
  extends Promise<Position | null>,
    Fragmentable {
  positionId: () => Promise<ID_Output>;
  department: <T = DepartmentPromise>() => T;
  basicSalary: () => Promise<Float>;
  otRate: () => Promise<Float>;
  jobRole: () => Promise<String>;
  contractBasis: () => Promise<Boolean>;
  PerContractPrice: () => Promise<Float>;
}

export interface LeaveDaySubscriptionPayload {
  mutation: MutationType;
  node: LeaveDay;
  updatedFields: String[];
  previousValues: LeaveDayPreviousValues;
}

export interface LeaveDaySubscriptionPayloadPromise
  extends Promise<LeaveDaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeaveDayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeaveDayPreviousValuesPromise>() => T;
}

export interface LeaveDaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeaveDaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeaveDaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeaveDayPreviousValuesSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LeaveDayPreviousValues {
  LeaveID: ID_Output;
  Day?: Int;
  Month?: Int;
  Year?: Int;
}

export interface LeaveDayPreviousValuesPromise
  extends Promise<LeaveDayPreviousValues>,
    Fragmentable {
  LeaveID: () => Promise<ID_Output>;
  Day: () => Promise<Int>;
  Month: () => Promise<Int>;
  Year: () => Promise<Int>;
}

export interface LeaveDayPreviousValuesSubscription
  extends Promise<AsyncIterator<LeaveDayPreviousValues>>,
    Fragmentable {
  LeaveID: () => Promise<AsyncIterator<ID_Output>>;
  Day: () => Promise<AsyncIterator<Int>>;
  Month: () => Promise<AsyncIterator<Int>>;
  Year: () => Promise<AsyncIterator<Int>>;
}

export interface EventPackageEdge {
  node: EventPackage;
  cursor: String;
}

export interface EventPackageEdgePromise
  extends Promise<EventPackageEdge>,
    Fragmentable {
  node: <T = EventPackagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventPackageEdgeSubscription
  extends Promise<AsyncIterator<EventPackageEdge>>,
    Fragmentable {
  node: <T = EventPackageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StaffPreviousValues {
  employeeID: ID_Output;
  employeeName?: String;
  nicNumber?: String;
  bankAccountNumber?: String;
  address?: String;
  phoneNumber?: String;
  workEmail?: String;
  password?: String;
  Age?: Int;
}

export interface StaffPreviousValuesPromise
  extends Promise<StaffPreviousValues>,
    Fragmentable {
  employeeID: () => Promise<ID_Output>;
  employeeName: () => Promise<String>;
  nicNumber: () => Promise<String>;
  bankAccountNumber: () => Promise<String>;
  address: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  workEmail: () => Promise<String>;
  password: () => Promise<String>;
  Age: () => Promise<Int>;
}

export interface StaffPreviousValuesSubscription
  extends Promise<AsyncIterator<StaffPreviousValues>>,
    Fragmentable {
  employeeID: () => Promise<AsyncIterator<ID_Output>>;
  employeeName: () => Promise<AsyncIterator<String>>;
  nicNumber: () => Promise<AsyncIterator<String>>;
  bankAccountNumber: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  workEmail: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  Age: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentEdge {
  node: Department;
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = DepartmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PhotoFrameTemplateSubscriptionPayload {
  mutation: MutationType;
  node: PhotoFrameTemplate;
  updatedFields: String[];
  previousValues: PhotoFrameTemplatePreviousValues;
}

export interface PhotoFrameTemplateSubscriptionPayloadPromise
  extends Promise<PhotoFrameTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoFrameTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoFrameTemplatePreviousValuesPromise>() => T;
}

export interface PhotoFrameTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoFrameTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoFrameTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoFrameTemplatePreviousValuesSubscription>() => T;
}

export interface AggregatePosition {
  count: Int;
}

export interface AggregatePositionPromise
  extends Promise<AggregatePosition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePositionSubscription
  extends Promise<AsyncIterator<AggregatePosition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LeaveDayEdge {
  node: LeaveDay;
  cursor: String;
}

export interface LeaveDayEdgePromise
  extends Promise<LeaveDayEdge>,
    Fragmentable {
  node: <T = LeaveDayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeaveDayEdgeSubscription
  extends Promise<AsyncIterator<LeaveDayEdge>>,
    Fragmentable {
  node: <T = LeaveDaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PositionPreviousValues {
  positionId: ID_Output;
  basicSalary?: Float;
  otRate?: Float;
  jobRole?: String;
  contractBasis?: Boolean;
  PerContractPrice?: Float;
}

export interface PositionPreviousValuesPromise
  extends Promise<PositionPreviousValues>,
    Fragmentable {
  positionId: () => Promise<ID_Output>;
  basicSalary: () => Promise<Float>;
  otRate: () => Promise<Float>;
  jobRole: () => Promise<String>;
  contractBasis: () => Promise<Boolean>;
  PerContractPrice: () => Promise<Float>;
}

export interface PositionPreviousValuesSubscription
  extends Promise<AsyncIterator<PositionPreviousValues>>,
    Fragmentable {
  positionId: () => Promise<AsyncIterator<ID_Output>>;
  basicSalary: () => Promise<AsyncIterator<Float>>;
  otRate: () => Promise<AsyncIterator<Float>>;
  jobRole: () => Promise<AsyncIterator<String>>;
  contractBasis: () => Promise<AsyncIterator<Boolean>>;
  PerContractPrice: () => Promise<AsyncIterator<Float>>;
}

export interface PositionSubscriptionPayload {
  mutation: MutationType;
  node: Position;
  updatedFields: String[];
  previousValues: PositionPreviousValues;
}

export interface PositionSubscriptionPayloadPromise
  extends Promise<PositionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PositionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PositionPreviousValuesPromise>() => T;
}

export interface PositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PositionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PositionPreviousValuesSubscription>() => T;
}

export interface StaffSubscriptionPayload {
  mutation: MutationType;
  node: Staff;
  updatedFields: String[];
  previousValues: StaffPreviousValues;
}

export interface StaffSubscriptionPayloadPromise
  extends Promise<StaffSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StaffPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StaffPreviousValuesPromise>() => T;
}

export interface StaffSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StaffSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StaffSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StaffPreviousValuesSubscription>() => T;
}

export interface PhotoFrameTemplatePreviousValues {
  FrameID: ID_Output;
  FrameName?: String;
  FrameMaterial?: String;
  PhotoFinish?: String;
  Price?: Int;
  Dimensions?: String;
}

export interface PhotoFrameTemplatePreviousValuesPromise
  extends Promise<PhotoFrameTemplatePreviousValues>,
    Fragmentable {
  FrameID: () => Promise<ID_Output>;
  FrameName: () => Promise<String>;
  FrameMaterial: () => Promise<String>;
  PhotoFinish: () => Promise<String>;
  Price: () => Promise<Int>;
  Dimensions: () => Promise<String>;
}

export interface PhotoFrameTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoFrameTemplatePreviousValues>>,
    Fragmentable {
  FrameID: () => Promise<AsyncIterator<ID_Output>>;
  FrameName: () => Promise<AsyncIterator<String>>;
  FrameMaterial: () => Promise<AsyncIterator<String>>;
  PhotoFinish: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Int>>;
  Dimensions: () => Promise<AsyncIterator<String>>;
}

export interface LeaveDay {
  LeaveID: ID_Output;
  Day?: Int;
  Month?: Int;
  Year?: Int;
}

export interface LeaveDayPromise extends Promise<LeaveDay>, Fragmentable {
  LeaveID: () => Promise<ID_Output>;
  StaffMember: <T = StaffPromise>() => T;
  Day: () => Promise<Int>;
  Month: () => Promise<Int>;
  Year: () => Promise<Int>;
}

export interface LeaveDaySubscription
  extends Promise<AsyncIterator<LeaveDay>>,
    Fragmentable {
  LeaveID: () => Promise<AsyncIterator<ID_Output>>;
  StaffMember: <T = StaffSubscription>() => T;
  Day: () => Promise<AsyncIterator<Int>>;
  Month: () => Promise<AsyncIterator<Int>>;
  Year: () => Promise<AsyncIterator<Int>>;
}

export interface LeaveDayNullablePromise
  extends Promise<LeaveDay | null>,
    Fragmentable {
  LeaveID: () => Promise<ID_Output>;
  StaffMember: <T = StaffPromise>() => T;
  Day: () => Promise<Int>;
  Month: () => Promise<Int>;
  Year: () => Promise<Int>;
}

export interface PhotoFrameTemplateEdge {
  node: PhotoFrameTemplate;
  cursor: String;
}

export interface PhotoFrameTemplateEdgePromise
  extends Promise<PhotoFrameTemplateEdge>,
    Fragmentable {
  node: <T = PhotoFrameTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoFrameTemplateEdgeSubscription
  extends Promise<AsyncIterator<PhotoFrameTemplateEdge>>,
    Fragmentable {
  node: <T = PhotoFrameTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  reset?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  reset: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  reset: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  reset: () => Promise<String>;
}

export interface EventPackage {
  PackageID: ID_Output;
  PackageName?: String;
  BookingCost?: Int;
  FoodPackage?: String;
  PhotographyServices?: String;
  Sounds?: String;
}

export interface EventPackagePromise
  extends Promise<EventPackage>,
    Fragmentable {
  PackageID: () => Promise<ID_Output>;
  PackageName: () => Promise<String>;
  BookingCost: () => Promise<Int>;
  FoodPackage: () => Promise<String>;
  PhotographyServices: () => Promise<String>;
  Sounds: () => Promise<String>;
}

export interface EventPackageSubscription
  extends Promise<AsyncIterator<EventPackage>>,
    Fragmentable {
  PackageID: () => Promise<AsyncIterator<ID_Output>>;
  PackageName: () => Promise<AsyncIterator<String>>;
  BookingCost: () => Promise<AsyncIterator<Int>>;
  FoodPackage: () => Promise<AsyncIterator<String>>;
  PhotographyServices: () => Promise<AsyncIterator<String>>;
  Sounds: () => Promise<AsyncIterator<String>>;
}

export interface EventPackageNullablePromise
  extends Promise<EventPackage | null>,
    Fragmentable {
  PackageID: () => Promise<ID_Output>;
  PackageName: () => Promise<String>;
  BookingCost: () => Promise<Int>;
  FoodPackage: () => Promise<String>;
  PhotographyServices: () => Promise<String>;
  Sounds: () => Promise<String>;
}

export interface Item {
  ItemId: ID_Output;
  ItemName?: String;
  Category?: String;
  Price?: Int;
  Stock?: Int;
  Brand?: String;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  ItemId: () => Promise<ID_Output>;
  ItemName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Int>;
  Stock: () => Promise<Int>;
  Brand: () => Promise<String>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  ItemId: () => Promise<AsyncIterator<ID_Output>>;
  ItemName: () => Promise<AsyncIterator<String>>;
  Category: () => Promise<AsyncIterator<String>>;
  Price: () => Promise<AsyncIterator<Int>>;
  Stock: () => Promise<AsyncIterator<Int>>;
  Brand: () => Promise<AsyncIterator<String>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  ItemId: () => Promise<ID_Output>;
  ItemName: () => Promise<String>;
  Category: () => Promise<String>;
  Price: () => Promise<Int>;
  Stock: () => Promise<Int>;
  Brand: () => Promise<String>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Department",
    embedded: false
  },
  {
    name: "Position",
    embedded: false
  },
  {
    name: "Staff",
    embedded: false
  },
  {
    name: "CardTemplate",
    embedded: false
  },
  {
    name: "PhotoFrameTemplate",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "LeaveDay",
    embedded: false
  },
  {
    name: "EventPackage",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
